#include "StdAfx.h"

#include "DbImporter.h"

#include "BLLLoggerFactory.h"
#include "frameworkConst.h"
#include "Result.h"
#include "StringResource.h"
#include "TaskManager.h"
#include "Path.h"
#include "RelationManager.h"

#include <cassert>
#include <cstdio>
#include <fstream>

using namespace stc::framework;


// development, user category/logger
DEFINE_STATIC_LOGGER("fmwk.bll.base.serial", devLogger);

CDbImporter::CDbImporter(uint32_t dataSetId):
	m_dataSetId(dataSetId)
{
}

CDbImporter::~CDbImporter()
{
	m_db.close();
    ClearMemoryTableMap();
}

void CDbImporter::LoadFromDatabase(const std::string& dbConnString)
{
	try 
	{
		OpenOutput(dbConnString);

		LoadParentChildInfo();

		LoadObjects();

		SetupOtherRelation();

		TranslateHandleProperty();

		ProcessDefaultChildObject();
	}
	catch (CppSQLite3Exception& exp)
	{
		LOG_ERROR(devLogger(), "DB Error : " << exp.errorMessage());

		throw stc::framework::CStcException("Database operation error");
	}
}

void CDbImporter::OpenOutput(const std::string& dbConnString)
{
	OpenDb(dbConnString);

	// when opening up a result db, if this is a summary, 
	// we will auto default to the first iteration db instead
	if (m_db.tableExists("EotResultIterations"))
	{
		CppSQLite3Query q = m_db.execQuery("SELECT DbFileName FROM EotResultIterations LIMIT 1");
		if (q.eof() || q.numFields() != 1)
		{
			throw stc::framework::CStcException("Summary database doesn't contain any iteration");	
		}

		const std::string newDbConnString = 
			Path::JoinPath(
				Path::GetDirectoryName(dbConnString), 
				q.fieldValue(0));

		std::ifstream is(newDbConnString.c_str());
		if (!is.is_open())
		{
			std::string errorMsg = "Configuration data is saved in " + newDbConnString + 
				" but this file cannot not be found relative to " + dbConnString + 
				". Either restore the relative location of the two files or load " + 
				newDbConnString + " directly.";
			throw stc::framework::CStcException(errorMsg);
		}
		is.close();

        // Close openned db
        q.finalize();
        m_db.close();

		OpenDb(newDbConnString);
	}


	// Auto default to the first Id
	if (m_dataSetId == 0)
	{
		m_dataSetId = m_db.execScalar("SELECT Id From DataSet LIMIT 1");
	}

	// check data set id
	std::ostringstream os;
	os << "SELECT COUNT(*) FROM DataSet WHERE Id = " << m_dataSetId;
	if (m_db.execScalar(os.str().c_str()) != 1)
	{
		throw stc::framework::CStcException("DataSetId doesn't exist in the database");	
	}
}

void CDbImporter::OpenDb(const std::string& dbConnString)
{
	// check if file exists
	std::ifstream is(dbConnString.c_str());
	if (!is.is_open())
	{
		std::string errorMsg = "Unable to open file " + dbConnString;
		throw stc::framework::CStcException(errorMsg);
	}
	is.close();

	m_db.open(dbConnString.c_str());
}

static bool IsMetaTable(const std::string& str)
{
	// RelationTable, DataSet, and maybe enum in the future
	return (str == "DataSet" || 
			str == "RelationTable" ||
			str == "HandleMap" ||
			str == "TableIndex" ||
			str == "Headers" ||
			str == "Descriptor" ||
			// these are generated by result reporter
			// in case user wants to open results as config
			str == "AllDevice" ||
			str == "RunOnceStatus" ||
			str == "EotResultIterations"
			);
}

static bool IsMetaProperty(const std::string& str)
{
	return (str == "Id" ||
			str == "DataSetId" ||
			str == "ParentHnd");
}

void CDbImporter::LoadParentChildInfo()
{
	assert(m_handleTree.empty());

	CppSQLite3Query tblQuery = 
		m_db.execQuery("SELECT name FROM SQLITE_MASTER WHERE type = \'table\'");

	for ( ; !tblQuery.eof(); tblQuery.nextRow())
	{
		const char* name = tblQuery.getStringField("name", "");
		assert(name != 0);

		const std::string strName = name;

		LoadTableParentChildInfo(strName);
	}

	ReorderParentChildRelation();
}

void CDbImporter::LoadTableParentChildInfo(const std::string& tableName)
{
	if (IsMetaTable(tableName))
		return;

    const std::string className = StringUtil::Replace(tableName, "_", ".");
	CMetaClass* cls = CMetaClassManager::Instance().GetClass(className);
	if (cls == 0)
	{
		LOG_WARN(devLogger(), "Skipping unknown class table " << className);
		//LOG_USER_ERROR(userLogger(), CResourceKey::DB_IMPORT_UNKNOWN_CLASS_TABLE_1, tableName);
		return;
	}

	if (cls->IsTypeOf(CResult::CLASS_ID()))
	{
		LOG_DEBUG(devLogger(), "Skipping result class table " << tableName);
		return;
	}

	assert(cls);

	std::ostringstream os;
	os << "SELECT Handle, ParentHnd FROM " << tableName << " WHERE DataSetId = " << m_dataSetId;
	std::string sql = os.str();

	CppSQLite3Query query;	
	{
		CTaskManager::CCtmReverseLock guard;
		query = m_db.execQuery(sql.c_str());
	}

	CTaskManager::CtmYielder ctmYielder(100);
	while (!query.eof())
	{		
		ctmYielder.CtmYield();

		StcHandle hnd = query.getIntField("Handle", NULL_STCHANDLE);
		Entry* entry = &m_entryMap[hnd];
		entry->handle = hnd;
		entry->parentHandle = query.getIntField("ParentHnd", NULL_STCHANDLE);
		entry->tableName = tableName;

		if (entry->parentHandle == NULL_STCHANDLE)
		{
			m_rootHandleList.push_back( entry );
		}
		else
		{
			m_handleTree[entry->parentHandle].push_back( entry );
		}

		query.nextRow();
	}
}


void CDbImporter::ReorderParentChildRelation()
{
	std::ostringstream os;
	os << "SELECT SourceHnd, TargetHnd FROM RelationTable WHERE DataSetId = " << m_dataSetId << " AND RelationTypeId = " << ParentChild().GetAsInt() << " ORDER BY ROWID";
	std::string sql = os.str();

	CppSQLite3Query query;
	{ 
		CTaskManager::CCtmReverseLock guard;
		query = m_db.execQuery(sql.c_str());
	}

	if (query.eof())
		return;

	for (HandleTree::iterator hit = m_handleTree.begin(); hit != m_handleTree.end(); ++hit)
	{
		hit->second.clear();
	}

	CTaskManager::CtmYielder ctmYielder(1024);
	StcHandle prevSrcHnd = NULL_STCHANDLE;
	EntryList* prevEntryList = NULL;
	
	while (!query.eof())
	{
		StcHandle srcHnd = query.getIntField("SourceHnd", NULL_STCHANDLE);
		StcHandle tgtHnd = query.getIntField("TargetHnd", NULL_STCHANDLE);
		query.nextRow();

		EntryMap::const_iterator eit = m_entryMap.find(tgtHnd);
		if (eit == m_entryMap.end())
			continue;

		EntryList* entryList = NULL;
		if (prevSrcHnd == srcHnd)
		{
			entryList = prevEntryList;
		}
		else
		{
			HandleTree::iterator it = m_handleTree.find(srcHnd);
			if (it != m_handleTree.end())
				entryList = &it->second;

			prevSrcHnd = srcHnd;
			prevEntryList = entryList;
		}

		if (entryList)
		{
			entryList->push_back(&eit->second);
		}

		ctmYielder.CtmYield();
	}
}

void CDbImporter::LoadObjects()
{
	EntryList unprocessList = m_rootHandleList;
	int processedEntryCnt = 0;

	CScriptableCreator ctor;

	CTaskManager::CtmYielder ctmYielder(100);

	while (!unprocessList.empty())
	{
		const Entry& entry = *unprocessList.front();
		unprocessList.pop_front();
		const EntryList& hnds = m_handleTree[entry.handle];
		unprocessList.insert(unprocessList.end(), hnds.begin(), hnds.end());

		LoadObject(ctor, entry);
		++processedEntryCnt;

		ctmYielder.CtmYield();
	}

    ClearMemoryTableMap();

	// Check for dangling nodes
	if (processedEntryCnt != static_cast<int>(m_handleTree.size()))
	{
		// CR 142793036; change this to just a log warning 
		// TODO: reenable this after result reporter handles joining iteration databases properly
		//throw CStcException("Database contains dangling children that were not loaded");
		LOG_WARN(devLogger(), 
			"Database contains dangling children that were not loaded. " <<
			"Expected: " << m_handleTree.size() << " loaded: " << processedEntryCnt);
	}
}

void CDbImporter::LoadObject(
	CScriptableCreator& ctor, 
	const Entry& entry)
{
	const HandleMap::iterator hit = m_handleMap.find(entry.parentHandle);
	CScriptable* parent = (hit == m_handleMap.end()? 0 : hit->second);
	const std::string& tableName = entry.tableName;
	const StcHandle handle = entry.handle;

    CMemoryTable *pTable = GetMemoryTable(tableName);
    CMetaClass *cls = pTable->GetMetaClass();

    bool rc = pTable->SetCurrentRow(handle); 

    if(rc)
    {
	    CScriptableAutoPtr<CScriptable> obj(ctor.CreateAP(cls->GetClassId(), parent, true, false));
    	
	    StcHandle hnd = handle;
	    if (obj.get() == 0)
	    {
		    throw CStcException("Unable to load object from the database.");
	    }

        obj->SetObjectHandleFromDb(hnd);
    	
	    if (!m_handleMap.insert(std::make_pair(hnd, obj.get())).second)
	    {
		    throw CStcException("Duplicate object error while loading from the database.");
	    }

	    stc::framework::CMetaPropertyIterator pit;
	    int i = 0;
	    for (pit = cls->PropertyBegin(); pit != cls->PropertyEnd(); ++pit, ++i)
	    {			
		    const MetaPropertyInfo& meta = pit->GetMetaInfo();

		    // We are filtering out noSave property on the load side for db serialization
		    // since users want to be able to see most of the noSave properties.
		    if (meta.noSave)
			    continue;			

		    assert(meta.id != FRAMEWORK_Scriptable_hHandle);

		    // Keep track of handle properties, since they need to be translated later.
		    if (meta.type == MetaPropertyInfo::HANDLE)
		    {
			    m_objMetaPropList[obj.get()].push_back(&meta);
		    }

		    const int columnId = pTable->GetColumnId(i);

		    if (columnId >= 0)
		    {
				const char *szValue = pTable->GetStringValue(columnId, "null");

				// Added for CR 120200017. Call Set() only if value is diffent.
				if(meta.type == MetaPropertyInfo::BOOL && !meta.IsCollection())
				{
					bool currentValue = obj->GetBool(meta.id);
					bool value = strcmp(szValue, "0") != 0;

					if (value != currentValue)
						obj->Set(meta.id, value);
				}
				else
				{
					std::string currentValue;
					obj->Get(meta.id, currentValue);

					if(currentValue != szValue)
						obj->Set(meta.id, szValue);
				}
		    }
	    }
    	
	    obj.release();
    }
}

void CDbImporter::SetupOtherRelation()
{
	// non-parent|result/child relation
	std::ostringstream os;
	os << "SELECT * FROM RelationTable WHERE DataSetId = " << m_dataSetId 
		<< " AND RelationTypeId <> " << ParentChild().GetAsInt() 
		<< " AND RelationTypeId <> " << ResultChild().GetAsInt() 
		<< " ORDER BY ROWID";
	std::string sql = os.str();

	CppSQLite3Query query;
	{
		CTaskManager::CCtmReverseLock guard;
		query = m_db.execQuery(sql.c_str());
	}

	CTaskManager::CtmYielder ctmYielder(100);
	while (!query.eof())
	{
		ctmYielder.CtmYield();

		StcHandle srcHnd = query.getIntField("SourceHnd", NULL_STCHANDLE);
		StcHandle tgtHnd = query.getIntField("TargetHnd", NULL_STCHANDLE);
		std::string relationType = query.getStringField("Type", "");

		HandleMap::const_iterator sit = m_handleMap.find(srcHnd);
		HandleMap::const_iterator tit = m_handleMap.find(tgtHnd);
		if (sit == m_handleMap.end() || sit->second == 0 ||
			tit == m_handleMap.end() || tit->second == 0)
		{
			query.nextRow();
			continue;
			//throw CStcException("Database contain invalid reference in the RelationTable");
		}
        const MetaRelationTypeInfo* relationInfo = 
					CRelationManager::Instance().GetMetaRelationType(relationType);
        if (!relationInfo)
        {
            throw CStcRunTimeError("Unable to find relation type info");
        }
        const RelationType relation = RelationType(relationInfo->typeId);
		if (sit->second->AddObject(*(tit->second), relation) == false)
		{
			throw CStcException("Unable to add the relation entry from the database");
		}

		query.nextRow();
	}
}

void CDbImporter::TranslateHandleProperty()
{
	CTaskManager::CtmYielder ctmYielder(100);

	// patch up handles references	
	for (ObjMetaPropList::const_iterator it = m_objMetaPropList.begin();
		 it != m_objMetaPropList.end(); ++it)
	{
		CScriptable* obj = it->first;

		ctmYielder.CtmYield();

		for (MetaPropList::const_iterator mpit = it->second.begin();
			 mpit != it->second.end(); ++mpit)
		{
			const bool isCollection = (*mpit)->IsCollection();
			const PropId propId = (*mpit)->id;

			if (isCollection)
			{
				CollectionProperty<StcHandle>& hndVec = 
					obj->GetCollection<StcHandle>(propId);

				std::vector<StcHandle> outputHndVec;
				const int count = hndVec.Count();
				for (int i = 0; i < count; ++i)
				{
					StcHandle hnd = hndVec.GetAt(i);
					if (hnd == NULL_STCHANDLE)
					{
						outputHndVec.push_back(hnd);
					}
					else
					{
						HandleMap::const_iterator hit = m_handleMap.find(hnd);
						if (hit != m_handleMap.end())
						{
							outputHndVec.push_back(hit->second->GetObjectHandle());
						}
					}
				}

				hndVec.Set(outputHndVec);
			}
			else
			{
				StcHandle hnd = obj->GetT<StcHandle>(propId);
				HandleMap::const_iterator hit = m_handleMap.find(hnd);
				if (hit != m_handleMap.end())
				{
					obj->SetT<StcHandle>(propId, hit->second->GetObjectHandle());
				}
				else
				{
					obj->SetT<StcHandle>(propId, NULL_STCHANDLE);
				}
			}

		}
	}
}

void CDbImporter::ProcessDefaultChildObject()
{
	// TODO: rework this later and need to fix xml as well
	//       added to support new default child
	CTaskManager::CtmYielder ctmYielder(100);

	CScriptableCreator ctor;
	for (HandleMap::const_iterator sit = m_handleMap.begin(); sit != m_handleMap.end(); ++sit)
	{
		CScriptable* obj = sit->second;
		CMetaClass::MetaRelationList relList = 
			obj->GetMetaClass().GetDefaultChildRelations();

		CMetaClass::MetaRelationList::const_iterator rit;
		for (rit = relList.begin(); rit != relList.end(); ++rit)
		{
			const ClassId clsId = (*rit)->class2;
			// TODO: optimize this to return count directly
			if (obj->GetObject(clsId) == 0)
			{
				const int minCnt = (*rit)->minOccurs;
				assert(minCnt > 0);
				for (int i = 0; i < minCnt; ++i)
				{
					ctor.Create(clsId, obj, true);
					ctmYielder.CtmYield();
				}
			}
			else
			{
				ctmYielder.CtmYield();
			}
		}
	}
}

CDbImporter::CMemoryTable* CDbImporter::GetMemoryTable(const std::string &tableName)
{
    MemoryTableMap::const_iterator it = memoryTableMap.find(tableName);

    if(it != memoryTableMap.end())
        return it->second;

    std::ostringstream os;
    os << "SELECT * FROM " << tableName 
       << " WHERE DataSetId = " << m_dataSetId;
    
    CppSQLite3Table *pSQLiteTable = 0;
	{
		CTaskManager::CCtmReverseLock guard;
		pSQLiteTable = new CppSQLite3Table(m_db.getTable(os.str().c_str()));
	}

    const std::string className = StringUtil::Replace(tableName, "_", ".");
    CMemoryTable *pTable = new CMemoryTable(pSQLiteTable, CMetaClassManager::Instance().GetClass(className));
    memoryTableMap.insert(make_pair(tableName, pTable));

    return pTable;
}

void CDbImporter::ClearMemoryTableMap()
{
    for(MemoryTableMap::const_iterator it = memoryTableMap.begin(); 
        it != memoryTableMap.end(); ++it)
    {
        delete it->second;
    }
    memoryTableMap.clear();
}

//////////////////////////////////////////////////////////////////////////////////
// CMemoryTable class.
CDbImporter::CMemoryTable::CMemoryTable(CppSQLite3Table *pTable, CMetaClass *pClass)
: m_pTable(pTable), m_pClass(pClass)
{
    assert(pTable);
    assert(pClass);

    BuildHandleToRowNumberMap();
    BuildColumnIdVector();
}

CDbImporter::CMemoryTable::~CMemoryTable()
{
    delete m_pTable;
}

void CDbImporter::CMemoryTable::BuildHandleToRowNumberMap()
{
    // Build handle to row number map
    int handleColumnIndex = GetHandleColumnIndex(); assert(handleColumnIndex != -1);
    
	CTaskManager::CtmYielder ctmYielder(500);
    for(int i = 0; i < m_pTable->numRows(); ++i)
    {
		ctmYielder.CtmYield();
        m_pTable->setRow(i);
        int handle = m_pTable->getIntField(handleColumnIndex, -1);
        m_handleToRowNumberMap.insert(std::make_pair(handle, i));
    }
}

void CDbImporter::CMemoryTable::BuildColumnIdVector()
{
	const int columntCount = GetColumnCount();

    std::vector<bool> usedColumns(columntCount, false);
	
	stc::framework::CMetaPropertyIterator pit;
	for (pit = m_pClass->PropertyBegin(); pit != m_pClass->PropertyEnd(); ++pit)
	{
		const MetaPropertyInfo& meta = pit->GetMetaInfo();
		bool found = false;
		for (int i = 0; i < columntCount; ++i)
		{
			if (meta.name == m_pTable->fieldName(i))
			{
                usedColumns[i] = true;
				m_columnIdVec.push_back(i);
				found = true;
				break;
			}
		}

		if (!found)
			m_columnIdVec.push_back(-1);
	}

    for (int i = 0; i < columntCount; ++i)
	{
        if (!usedColumns[i])
        {
		    const std::string colName = m_pTable->fieldName(i);

		    if (!IsMetaProperty(colName))
		    {
			    LOG_USER_WARN(devLogger(), CResourceKey::DB_IMPORT_UNKNOWN_CLASS_PROPERTY_2, 
				    m_pClass->GetMetaInfo().name << colName);
		    }
        }
	}
}

int CDbImporter::CMemoryTable::GetHandleColumnIndex() const
{
    for(int i = m_pTable->numFields() - 1; i >= 0; --i)
    {
        if(!strcmp(m_pTable->fieldName(i), "Handle"))
            return i;
    }

    return -1;
}

bool CDbImporter::CMemoryTable::SetCurrentRow(StcHandle handle)
{
    HandleToRowNumberMap::const_iterator it = m_handleToRowNumberMap.find(handle);

    if(it != m_handleToRowNumberMap.end())
    {
        m_pTable->setRow(it->second);
        return true;
    }

    return false;
}

