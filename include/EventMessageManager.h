#ifndef INCLUDED_EVENT_MESSAGE_MANAGER_H
#define INCLUDED_EVENT_MESSAGE_MANAGER_H

#include "EventMessage.h"
#include "Delegate.h"
#include "StcExport.h"
#include "StcCollections.h"
#include <log4cplus/loglevel.h> // log4cplus loglevels
#include "MetaClass.h"
namespace stc {
namespace framework {

class CScriptable;

class STC_PUBLIC CEventMessageManager 
{

public:

    /// Returns singleton instance
    static CEventMessageManager & Instance();

    /// Writes an event message using current PC time
    void Write(
        const CScriptable * s,
        const EventMessageType & type,
        const std::string & msg,
        log4cplus::LogLevel logLevel = log4cplus::INFO_LOG_LEVEL);

    /// Writes an event message using specified timestamp
    void Write(
        const CScriptable * s,
        const EventMessageType & type,
        const std::string & msg,
        double timestamp,
        log4cplus::LogLevel logLevel = log4cplus::INFO_LOG_LEVEL);

    /// The "All" hardcoded event type group name
    static const std::string allGroupName;

    /// The "Default" hardcoded event type group name
    static const std::string defaultGroupName;

    /// Fills classIdVec with classIds that generate events in eventGroupName
    void GetClassIdsInEventGroup(
        const std::string & eventGroupName, 
        std::vector<ClassId> & classIdVec);

    /// Fills emtVec with event types in eventGroupName generated by instances of classId
    void GetEventTypesForClassId(
        const ClassId & classId, 
        const std::string & eventGroupName, 
        EventMessageTypeVec & emtVec);

    ////////////////////////////
    // INFRASTRUCTURE INTERFACES

    typedef stc::framework::Delegate < stc::framework::FastDelegate2<const stc::framework::EventMessage &, log4cplus::LogLevel> > PublicationDelegate;

    /// Infrastructure interface. Registers a publication delegate to be called when an object in svec generates an event in evec.
    void RegisterPublicationDelegate(
        const ScriptableVec & svec,
        const EventMessageTypeVec & evec,
        const PublicationDelegate & d);

    /// Infrastructure interface. Unregisters a publication delegate for specified event types on specified scriptables
    void UnregisterPublicationDelegate(
        const ScriptableVec & svec,
        const EventMessageTypeVec & evec,
        const PublicationDelegate & d);

    /// Infrastructure interface. Unregisters a publication delegate for all event types on all scriptables
    void UnregisterPublicationDelegate( 
        const PublicationDelegate & d);


    typedef stc::framework::Delegate <stc::framework::FastDelegate0<> > InitDelegate;

    /// Infrastructure interface. Called by base.dll after all plug-ins are loaded
    void Initialize();

    /// Infrastructure interface. Returns true if EventMessageManager is initialized
    bool IsInitialized();

    /// Infrastructure interface. Registers an InitDelegate to be called after EventMessageManager is initialized
    void RegisterInitDelegate(const InitDelegate & d);

    /// Infrastructure interface. Unregisters an InitDelegate
    void UnregisterInitDelegate(const InitDelegate & d);
    
private:

    // Initialization stuff
    InitDelegate m_initDelegate;
    bool m_initialized;

    // Publication stuff
    typedef std::map<EventMessageType, PublicationDelegate> EventPublisherMap;
    typedef std::map<const stc::framework::CScriptable *, EventPublisherMap> InstanceEventPublisherMap;
    InstanceEventPublisherMap m_publisherMap;

    // Event type stuff
    typedef std::map<ClassId, EventMessageTypeVec> ClassEventTypeMap;
    typedef std::map<std::string, ClassEventTypeMap> EventGroupMap;
    EventGroupMap m_eventGroupMap;

    // internal helper methods
    void OnScriptableDelete(CScriptable * s, ClassId classId);

    template <class T>
    void GetAttribute(const CMetaClass * mc, const std::string & name, T* attr)
    {
        std::ostringstream oss;
        oss << "EventMessage" << name << "Types";
        *attr = dynamic_cast<T>(mc->FindAttribute(oss.str(), false));
    }

    // don't create, use Instance()
    CEventMessageManager();
    CEventMessageManager(const CEventMessageManager &);
    CEventMessageManager & operator=(const CEventMessageManager &);
};
}
}

#endif //INCLUDED_EVENT_MESSAGE_MANAGER_H

